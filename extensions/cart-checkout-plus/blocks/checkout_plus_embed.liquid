{% comment %}
  Checkout+ App Embed
  Automatically injects into cart drawer and cart page
{% endcomment %}

<script>
(function() {
  'use strict';
  
  const CASHBACK_PERCENT = 5;
  const INSURANCE_PERCENT = 4;
  const PROTECTION_HANDLE = 'order-protection';
  const PROTECTION_TITLE = 'Checkout+'; // Product display name - change here if renamed
  const EMBED_ID = 'checkout-plus-embed-' + Date.now();
  
  // Prevent duplicate injection
  if (window.checkoutPlusEmbedLoaded) {
    return;
  }
  window.checkoutPlusEmbedLoaded = true;
  
  // Store original fetch before any modifications (needed for checkbox handler)
  const originalFetch = window.fetch;
  
  // Common cart drawer selectors (works with most themes)
  // More dynamic approach - look for any element with cart-related keywords
  const CART_KEYWORDS = ['cart', 'drawer', 'mini', 'slide', 'popup', 'modal', 'upcart', 'sidecart'];
  
  const CART_DRAWER_SELECTORS = [
    '.styles_CartPreview__card__',  // Upcart
    '[id*="cart-drawer"]',
    '[id*="CartDrawer"]',
    '[class*="cart-drawer"]',
    '[class*="CartDrawer"]',
    '[id*="drawer-cart"]',
    '[class*="drawer-cart"]',
    'cart-drawer',
    'cart-notification',
    '[id*="mini-cart"]',
    '[class*="mini-cart"]'
  ];
  
  // Dynamic detection: Find any visible element with cart keywords and checkout button
  function findCartDrawerDynamically() {
    const allElements = document.querySelectorAll('*');
    
    for (const el of allElements) {
      // Skip if not visible
      const style = window.getComputedStyle(el);
      if (style.display === 'none' || style.visibility === 'hidden' || style.opacity === '0') {
        continue;
      }
      
      // Check if element has cart-related class/id AND contains checkout button
      const hasCartKeyword = CART_KEYWORDS.some(keyword => {
        const id = (el.id || '').toLowerCase();
        const className = (el.className || '').toString().toLowerCase();
        return id.includes(keyword) || className.includes(keyword);
      });
      
      if (hasCartKeyword) {
        // Check if it contains a checkout button
        const hasCheckoutBtn = el.querySelector('[href*="/checkout"], [href*="checkout"], button[name="checkout"], .checkout-button, [class*="checkout"]');
        if (hasCheckoutBtn) {
          console.log('[Checkout+ Embed] Dynamic cart drawer found:', el);
          return el;
        }
      }
    }
    
    return null;
  }
  
  // Common cart page selectors
  const CART_PAGE_SELECTORS = [
    'form[action*="/cart"]',
    '[id*="cart"]',
    'main-cart-items',
    'cart-items',
    '.cart'
  ];
  
  // Common cart footer/actions selectors (where checkout button lives)
  const CART_FOOTER_SELECTORS = [
    '.upcart-footer',                      // ADD THIS
  '.upcart-checkout-button-container',   // ADD THIS
  'cart-footer',
  'cart-actions',
    'cart-footer',
    'cart-actions',
    '.cart-footer',
    '.cart-actions',
    '[class*="cart-footer"]',
    '[class*="cart-actions"]',
    '.cart__footer',
    '.cart__actions',
    '[class*="subtotal"]',
    '.cart__ctas',
    '[data-cart-footer]'
  ];
  
  let injectedInstances = new Set();
  
  // Create the UI component
  function createCheckoutPlusUI() {
    const container = document.createElement('div');
    container.className = 'checkout-plus-embed';
    container.id = EMBED_ID;
    container.setAttribute('data-cart-total', '0');
    container.setAttribute('data-protection-handle', PROTECTION_HANDLE);
    
    container.innerHTML = `
      <style>
        /* Hide Order Protection from UI - Standard Shopify cart */
        tr.cart-item:has(a[href*="/products/order-protection"]) {
          position: absolute !important;
          visibility: hidden !important;
        }
        
        /* Hide Order Protection from UI - Upcart */
        .styles_ProductRow__product__:has(a[href*="/products/order-protection"]),
        .upcart-product-item:has(a[href*="/products/order-protection"]),
        div[id*="order-protection"] {
          position: absolute !important;
          visibility: hidden !important;
        }
        
        /* Generic fallback for other cart apps */
        *:has(> a[href*="/products/order-protection"]) {
          position: absolute !important;
          visibility: hidden !important;
        }
        
        /* Remove ::after pseudo-element from checkout button that creates border */
        .cart__checkout-button::after,
        button[name="checkout"]::after,
        #CartDrawer-Checkout::after {
          display: none !important;
          content: none !important;
        }
        
        /* Loading spinner */
        .checkout-plus-spinner {
          display: inline-block;
          width: 18px;
          height: 18px;
          border: 2px solid rgba(255, 255, 255, 0.3);
          border-radius: 50%;
          border-top-color: #fff;
          animation: checkout-plus-spin 0.8s linear infinite;
          vertical-align: middle;
        }
        
        @keyframes checkout-plus-spin {
          to { transform: rotate(360deg); }
        }
        
        .checkout-plus-embed {
          marginTop: 16px;

        }
        
        .checkout-plus-header {
          display: flex;
          justify-content: space-between;
          align-items: center;
          margin-bottom: 8px;
        }
        
        .checkout-plus-title {
          font-weight: 400;
          font-size: 14px;
          margin: 0;
          color: #000;
        }
        
        .checkout-plus-fee {
          font-size: 14px;
          font-weight: 400;
          color: #000;
          transition: opacity 0.2s ease;
        }
        
        .checkout-plus-description {
          font-size: 13px;
          color: #666;
          margin: 0 0 16px 0;
          line-height: 1.4;
        }
        
        .checkout-plus-price,
        .checkout-plus-cashback,
        .checkout-plus-total {
          transition: opacity 0.2s ease;
        }
        
        .checkout-plus-btn-primary {
          width: 100%;
          padding: 18px;
          border: none;
          border-radius: 40px;
          font-size: 16px;
          font-weight: 600;
          cursor: pointer;
          transition: opacity 0.2s;
          text-transform: uppercase;
          background: #142b6f;
          color: white;
          margin-top: 4px;
        }
        
        .checkout-plus-btn-primary:disabled {
          opacity: 0.6;
          cursor: not-allowed;
        }
        
        .checkout-plus-btn-primary:hover:not(:disabled) {
          opacity: 0.9;
        }
        
        .checkout-plus-embed:not([data-injected]) {
       
        }
      </style>
      
      <div class="checkout-plus-header">
        <span class="checkout-plus-title">Checkout+</span>
        <span class="checkout-plus-fee">$<span class="checkout-plus-price">0.00</span></span>
      </div>
      
      <p class="checkout-plus-description">
        Get Free Returns, $<span class="checkout-plus-cashback">0.00</span> CashBack, Delivery Protection, and a 30-day Guarantee.
      </p>
      
      <button 
        class="checkout-plus-btn-primary" 
        id="checkout-plus-with-protection-${EMBED_ID}"
      >
        CHECKOUT+ | <span class="checkout-plus-total">$0.00</span>
      </button>
    `;
    
    return container;
  }
  
  // Find cart container (drawer or page)
  function findCartContainer() {
    // Try predefined selectors first (faster)
    for (const selector of CART_DRAWER_SELECTORS) {
      const drawer = document.querySelector(selector);
      if (drawer && (drawer.offsetParent !== null || drawer.style.display !== 'none')) {
        return { container: drawer, type: 'drawer' };
      }
    }
    
    // Fallback: Dynamic detection for unknown cart implementations
    const dynamicCart = findCartDrawerDynamically();
    if (dynamicCart) {
      return { container: dynamicCart, type: 'drawer' };
    }
    
    // Check for cart page
    if (window.location.pathname === '/cart' || window.location.pathname.includes('/cart')) {
      for (const selector of CART_PAGE_SELECTORS) {
        const page = document.querySelector(selector);
        if (page) {
          return { container: page, type: 'page' };
        }
      }
    }
    
    return null;
  }
  
  // Hide the Order Protection product from cart display
  function hideProtectionProduct() {
    // Find all links in the cart
    const allLinks = document.querySelectorAll('a');
    
    for (const link of allLinks) {
      const linkText = (link.textContent || link.innerText || '').trim();
      
      // Check if this link contains the protection product title
      if (linkText.includes(PROTECTION_TITLE) || linkText.toLowerCase().includes('protection')) {
        console.log('[checkout_plus] Found protection product link:', link);
        
        // Go up 6 levels to find the product container
        let container = link;
        for (let i = 0; i < 6; i++) {
          if (container.parentElement) {
            container = container.parentElement;
          } else {
            break;
          }
        }
        
        // Hide the container
        // if (container && container !== document.body && container !== document.documentElement) {
        //  container.style.display = 'none';
        // console.log('[Checkout+ Embed] Hidden protection product container:', container);
        // }
      }
    }
  }
  
  // Find insertion point in cart
  function findInsertionPoint(cartContainer) {
    // For Upcart, just return the footer - we'll replace its contents
    const upcartFooter = cartContainer.querySelector('.upcart-footer');
    if (upcartFooter) {
      return upcartFooter;
    }
    
    // Try cart footer first (best UX) for other carts
    for (const selector of CART_FOOTER_SELECTORS) {
      const footer = cartContainer.querySelector(selector);
      if (footer) {
        return footer;
      }
    }
    
    // Try to find cart items container and insert before footer
    const itemsContainer = cartContainer.querySelector('[class*="cart-items"], [id*="cart-items"], main-cart-items, cart-items');
    if (itemsContainer && itemsContainer.parentElement) {
      return itemsContainer.parentElement;
    }
    
    // Fallback: insert at end of cart container
    return cartContainer;
  }
  
  // Inject UI into cart
  function injectUI() {
    console.log('[checkout_plus] injectUI called');
    const cartInfo = findCartContainer();
    if (!cartInfo) {
      console.log('[checkout_plus] No cart container found');
      return false;
    }
    
    const { container, type } = cartInfo;
    console.log('[checkout_plus] Cart container found:', type, container);
    const instanceId = `${type}-${container.id || container.className}`;
    
    // Check if already injected in this container and still properly rendered
    const existingEmbed = container.querySelector('.checkout-plus-embed');
    if (existingEmbed && existingEmbed.isConnected) {
      const hasButton = existingEmbed.querySelector('.checkout-plus-btn-primary');
      if (hasButton) {
        console.log('[checkout_plus] Embed already exists and is complete');
        injectedInstances.add(instanceId);
        return true;
      } else {
        console.log('[checkout_plus] Embed exists but is incomplete, removing and re-injecting');
        existingEmbed.remove();
        injectedInstances.delete(instanceId);
      }
    }
    
    const insertionPoint = findInsertionPoint(container);
    console.log('[checkout_plus] Insertion point found:', insertionPoint);
    if (!insertionPoint) {
      console.log('[checkout_plus] No insertion point found');
      return false;
    }
    
    const ui = createCheckoutPlusUI();
    ui.setAttribute('data-injected', 'true');
    console.log('[checkout_plus] UI created, about to inject');
    
    // Special handling for Upcart - clear footer and inject our UI
    const isUpcartFooter = insertionPoint.classList.contains('upcart-footer');
    if (isUpcartFooter) {
      // Clear the footer completely
      insertionPoint.innerHTML = '';
      
      // Inject our UI
      insertionPoint.appendChild(ui);
      
      // Add checkout link below
      const checkoutLink = document.createElement('a');
      checkoutLink.href = '/checkout';
      checkoutLink.textContent = 'No, go to checkout';
      checkoutLink.style.cssText = 'display: block; text-align: center; color: #666; font-size: 14px; text-decoration: underline; padding: 12px 0; cursor: pointer;';
      checkoutLink.addEventListener('mouseenter', function() {
        this.style.color = '#333';
      });
      checkoutLink.addEventListener('mouseleave', function() {
        this.style.color = '#666';
      });
      insertionPoint.appendChild(checkoutLink);
    } else {
      // Standard injection for other carts
      insertionPoint.appendChild(ui);
    }
    
    injectedInstances.add(instanceId);
    console.log('[checkout_plus] UI injected successfully at:', insertionPoint);
    initializeUI(ui);
    
    // Hide the protection product from display
    hideProtectionProduct();
    
    return true;
  }
  
  // Initialize UI functionality
  function initializeUI(container) {
    const checkoutWithBtn = container.querySelector(`#checkout-plus-with-protection-${EMBED_ID}`);
    const totalSpan = container.querySelector('.checkout-plus-total');
    const priceSpan = container.querySelector('.checkout-plus-price');
    const cashbackSpan = container.querySelector('.checkout-plus-cashback');
    
    if (!checkoutWithBtn || !totalSpan || !cashbackSpan || !priceSpan) {
      return;
    }
    
    // Find and modify the default checkout button text and behavior
    const defaultCheckoutBtn = document.querySelector('[name="checkout"], button[type="submit"], .cart__checkout-button, [class*="checkout-button"]');
    if (defaultCheckoutBtn) {
      // Change button text
      defaultCheckoutBtn.textContent = 'No, go to checkout';
      
      // Style as a text link instead of button
      defaultCheckoutBtn.style.background = 'none';
      defaultCheckoutBtn.style.border = 'none';
      defaultCheckoutBtn.style.color = '#666';
      defaultCheckoutBtn.style.fontSize = '14px';
      defaultCheckoutBtn.style.fontWeight = '400';
      defaultCheckoutBtn.style.textDecoration = 'underline';
      defaultCheckoutBtn.style.cursor = 'pointer';
      defaultCheckoutBtn.style.padding = '8px 0';
      defaultCheckoutBtn.style.textAlign = 'center';
      defaultCheckoutBtn.style.textTransform = 'none';
      
      // Hover effect
      defaultCheckoutBtn.addEventListener('mouseenter', function() {
        this.style.color = '#333';
      });
      defaultCheckoutBtn.addEventListener('mouseleave', function() {
        this.style.color = '#666';
      });
      
      // Override click to remove protection first
      defaultCheckoutBtn.addEventListener('click', async function(e) {
        e.preventDefault();
        
        try {
          // Remove protection if it exists
          const cartRes = await originalFetch('/cart.js');
          const cart = await cartRes.json();
          const protectionItem = cart.items.find(item => item.handle === PROTECTION_HANDLE);
          
          if (protectionItem) {
            await originalFetch('/cart/change.js', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ id: protectionItem.key, quantity: 0 }),
            });
          }
        } catch (err) {
          console.error('Failed to remove protection:', err);
        }
        
        // Go to checkout
        window.location.href = '/checkout';
      }, { once: false });
    }
    
    // Calculate prices based on current cart
    let isUpdating = false;
    let lastUpdateTime = 0;
    
    function updatePrices() {
      // Debounce: Don't update more than once per 500ms
      const now = Date.now();
      if (now - lastUpdateTime < 500) {
        console.log('[checkout_plus] updatePrices debounced (too soon)');
        return;
      }
      lastUpdateTime = now;
      
      console.log('[checkout_plus] updatePrices - fetching cart');
      
      // Show loading state
      if (!isUpdating) {
        isUpdating = true;
        priceSpan.style.opacity = '0.5';
        totalSpan.style.opacity = '0.5';
        cashbackSpan.style.opacity = '0.5';
      }
      
      fetch('/cart.js')
        .then(res => res.json())
        .then(cart => {
          // Calculate total excluding protection product
          let cartTotal = 0;
          let protectionVariantId = null;
          
          cart.items.forEach(item => {
            if (item.handle !== PROTECTION_HANDLE) {
              cartTotal += item.final_line_price;
            } else {
              protectionVariantId = item.variant_id;
            }
          });
          
          // Convert from cents to dollars
          cartTotal = cartTotal / 100;
          
          const insuranceFee = (cartTotal * INSURANCE_PERCENT / 100).toFixed(2);
          const cashbackAmount = (cartTotal * CASHBACK_PERCENT / 100).toFixed(2);
          const totalWithProtection = (cartTotal + parseFloat(insuranceFee)).toFixed(2);
          
          // Update with smooth transition
          priceSpan.textContent = insuranceFee;
          totalSpan.textContent = '$' + totalWithProtection;
          cashbackSpan.textContent = cashbackAmount;
          
          // Remove loading state
          priceSpan.style.opacity = '1';
          totalSpan.style.opacity = '1';
          cashbackSpan.style.opacity = '1';
          isUpdating = false;
          
          // Show/hide based on cart total
          if (cartTotal > 0) {
            container.style.display = 'block';
          } else {
            container.style.display = 'none';
          }
        })
        .catch(err => {
          console.error('Failed to fetch cart:', err);
          // Remove loading state on error
          priceSpan.style.opacity = '1';
          totalSpan.style.opacity = '1';
          cashbackSpan.style.opacity = '1';
          isUpdating = false;
        });
    }
    
    // Initial price calculation
    updatePrices();
    
    // Handle "CHECKOUT+" button click
    let isProcessing = false;
    checkoutWithBtn.addEventListener('click', async function(e) {
      e.preventDefault();
      
      if (isProcessing) return;
      
      isProcessing = true;
      checkoutWithBtn.disabled = true;
      checkoutWithBtn.innerHTML = '<span class="checkout-plus-spinner"></span>';
      
      try {
        // First, check if protection product is already in cart
        const cartCheckResponse = await originalFetch('/cart.js');
        const currentCart = await cartCheckResponse.json();
        const alreadyHasProtection = currentCart.items.some(item => item.handle === PROTECTION_HANDLE);
        
        if (!alreadyHasProtection) {
          // Protection not in cart, add it
          const response = await originalFetch(`/products/${PROTECTION_HANDLE}.js`);
          if (!response.ok) {
            throw new Error('Product not found');
          }
          
          const product = await response.json();
          
          if (!product || !product.variants || product.variants.length === 0) {
            throw new Error('Protection product not available');
          }
          
          const variantId = product.variants[0].id;
          
          // Add to cart using AJAX API
          const addResponse = await originalFetch('/cart/add.js', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              id: variantId,
              quantity: 1,
            }),
          });
          
          if (!addResponse.ok) {
            const errorData = await addResponse.json().catch(() => ({}));
            throw new Error(errorData.description || 'Failed to add to cart');
          }
          
          const addResult = await addResponse.json();
          if (addResult.errors && Object.keys(addResult.errors).length > 0) {
            throw new Error(Object.values(addResult.errors)[0]);
          }
          
          console.log('✅ Protection added to cart');
        } else {
          console.log('✅ Protection already in cart, proceeding to checkout');
        }
        
        // Go to checkout
        window.location.href = '/checkout';
        
      } catch (error) {
        console.error('❌ Failed to add protection:', error);
        checkoutWithBtn.disabled = false;
        const currentTotal = totalSpan.textContent;
        checkoutWithBtn.innerHTML = 'CHECKOUT+ | <span class="checkout-plus-total">' + currentTotal + '</span>';
      }
    });
    
    // Listen for cart updates - Standard Shopify events
    document.addEventListener('cart:updated', () => {
      updatePrices();
      autoRemoveProtectionIfCartEmpty();
    });
    document.addEventListener('cart:refresh', () => {
      updatePrices();
      autoRemoveProtectionIfCartEmpty();
    });
    window.addEventListener('cart:updated', () => {
      updatePrices();
      autoRemoveProtectionIfCartEmpty();
    });
    window.addEventListener('cart:refresh', () => {
      updatePrices();
      autoRemoveProtectionIfCartEmpty();
    });
    
    // Upcart-specific events
    window.addEventListener('upcart:cart-updated', () => {
      console.log('[checkout_plus] Upcart cart-updated event');
      updatePrices();
      autoRemoveProtectionIfCartEmpty();
    });
    document.addEventListener('upcart:cart-updated', () => {
      console.log('[checkout_plus] Upcart cart-updated event (document)');
      updatePrices();
      autoRemoveProtectionIfCartEmpty();
    });
  }
  
  // Retry injection with exponential backoff for race conditions
  let injectionRetries = 0;
  const MAX_RETRIES = 5;
  
  function retryInjection(delay = 300) {
    if (injectionRetries >= MAX_RETRIES) {
      console.log('[checkout_plus] Max injection retries reached');
      return;
    }
    
    // Check if UI already exists and is properly rendered
    const existingUI = document.querySelector('.checkout-plus-embed');
    if (existingUI && existingUI.isConnected) {
      const hasButton = existingUI.querySelector('.checkout-plus-btn-primary');
      if (hasButton) {
        console.log('[checkout_plus] UI already exists and is complete');
        return;
      }
    }
    
    injectionRetries++;
    console.log('[checkout_plus] Retry injection attempt:', injectionRetries);
    
    setTimeout(() => {
      const success = injectUI();
      if (!success || injectionRetries < 3) {
        // Retry with exponential backoff
        retryInjection(delay * 1.5);
      } else {
        injectionRetries = 0; // Reset for next time
      }
    }, delay);
  }
  
  // ============================================================================
  // AUTO-REMOVE PROTECTION WHEN CART BECOMES EMPTY
  // ============================================================================
  

  let lastCartItemCount = -1;
  
  // Configurable selectors for different cart themes/apps
  const CART_ITEM_SELECTORS = [
    '.cart-item',                           // Standard Shopify
    'tr[id*="CartDrawer-Item"]',           // Standard Shopify table
    '.styles_ProductRow__product__',       // Upcart
    '.upcart-product-item',                // Upcart
    // Add more cart item selectors here as needed
  ];
  
  const ITEM_NAME_SELECTORS = [
    '.cart-item__name',                    // Standard Shopify
    'a[href*="order-protection"]',         // Generic link
    '.upcart-product-title-link',          // Upcart
    '.upcart-product-title a',             // Upcart alternative
    // Add more product name selectors here as needed
  ];
  
  const DELETE_BUTTON_SELECTORS = [
    'cart-remove-button button',                    // Standard Shopify
    `button[aria-label*="Remove ${PROTECTION_TITLE}"]`, // Standard Shopify aria (dynamic)
    'button[aria-label*="Remove"]',                 // Generic remove button
    '.styles_TrashButton__deleteButton__',          // Upcart delete div
    '.styles_TrashButton__deleteButton__ svg',      // Upcart delete SVG
    'button[aria-label*="Decrease quantity"]',      // Quantity minus button fallback
    // Add more delete button selectors here as needed
  ];
  
  /**
   * Check if cart has only protection product, and remove it by clicking its delete button
   */
  function autoRemoveProtectionIfCartEmpty() {
    originalFetch('/cart.js')
      .then(res => res.json())
      .then(cart => {
        console.log('[checkout_plus] Checking cart, total items:', cart.items.length);
        
        // Count regular items (exclude protection)
        const regularItems = cart.items.filter(item => item.handle !== PROTECTION_HANDLE);
        const hasProtection = cart.items.some(item => item.handle === PROTECTION_HANDLE);
        
        console.log('[checkout_plus] Regular items:', regularItems.length, 'Has protection:', hasProtection);
        
        // Track changes
        if (lastCartItemCount !== -1 && regularItems.length !== lastCartItemCount) {
          console.log('[checkout_plus] Item count changed:', lastCartItemCount, '->', regularItems.length);
        }
        lastCartItemCount = regularItems.length;
        
        // If cart empty but protection exists, remove it
        if (regularItems.length === 0 && hasProtection) {
          console.log('[checkout_plus] Cart empty, removing protection by clicking delete button');
          clickProtectionRemoveButton();
        }
      })
      .catch(err => console.error('[checkout_plus] Cart check failed:', err));
  }
  
  /**
   * Find and click the remove button for the protection product
   */
  function clickProtectionRemoveButton() {
    // Try each cart item selector
    for (const itemSelector of CART_ITEM_SELECTORS) {
      const cartRows = document.querySelectorAll(itemSelector);
      
      for (const row of cartRows) {
        // Try each name selector to find the protection product
        let foundProtection = false;
        
        for (const nameSelector of ITEM_NAME_SELECTORS) {
          const itemName = row.querySelector(nameSelector);
          if (itemName && (
            itemName.textContent.includes(PROTECTION_TITLE) ||
            itemName.href?.includes('order-protection')
          )) {
            foundProtection = true;
            console.log('[checkout_plus] Found protection row:', row);
            break;
          }
        }
        
        if (foundProtection) {
          // Try each delete button selector
          for (const btnSelector of DELETE_BUTTON_SELECTORS) {
            const removeElement = row.querySelector(btnSelector);
            if (removeElement) {
              console.log('[checkout_plus] Found delete element:', btnSelector);
              
              // Click the element (or its parent button if it's an SVG)
              if (removeElement.tagName === 'BUTTON') {
                removeElement.click();
              } else if (removeElement.tagName === 'svg' || removeElement.tagName === 'SVG') {
                // For SVG, click its parent or the element itself
                const btn = removeElement.closest('button') || removeElement.parentElement;
                if (btn) btn.click();
                else removeElement.click();
              } else {
                // For divs or other elements, try clicking directly
                removeElement.click();
              }
              
              console.log('[checkout_plus] Clicked delete button');
              return;
            }
          }
        }
      }
    }
    
    console.log('[checkout_plus] Protection remove button not found');
  }
  
  /**
   * Poll cart periodically when drawer is visible
   */
  setInterval(() => {
    const cartDrawer = document.querySelector('.styles_CartPreview__card__, [id*="cart-drawer"], [class*="cart-drawer"]');
    if (cartDrawer && cartDrawer.offsetParent !== null) {
      autoRemoveProtectionIfCartEmpty();
    }
  }, 2000);
  
  /**
   * Watch for DOM changes - detect when cart items are removed
   */
  const autoRemoveObserver = new MutationObserver((mutations) => {
    mutations.forEach((mutation) => {
      mutation.removedNodes.forEach((node) => {
        if (node.nodeType === 1) {
          // Check if removed node is a cart item
          const isCartItem = node.classList && (
            node.classList.contains('cart-item') ||
            (node.hasAttribute('id') && node.id.includes('CartDrawer-Item'))
          );
          
          if (isCartItem) {
            console.log('[checkout_plus] Cart item removed, checking if should remove protection');
            setTimeout(() => autoRemoveProtectionIfCartEmpty(), 500);
          }
        }
      });
    });
  });
  
  // Start observing cart for item removals
  setTimeout(() => {
    const cartContainer = document.querySelector('.styles_CartPreview__card__, [id*="cart-drawer"], [class*="cart-drawer"]');
    if (cartContainer) {
      autoRemoveObserver.observe(cartContainer, { childList: true, subtree: true });
      console.log('[checkout_plus] Monitoring cart for item removals');
    }
  }, 2000);
  
  // ============================================================================
  
  // Listen for cart:add events (when Add to Cart button is clicked)
  document.addEventListener('cart:add', function() {
    console.log('[checkout_plus] cart:add event detected');
    injectionRetries = 0;
    // Wait longer for cart drawer to fully render after add
    setTimeout(() => retryInjection(500), 800);
  });
  
  // Listen for theme-specific cart add events
  window.addEventListener('cart:add', function() {
    console.log('[checkout_plus] window cart:add event detected');
    injectionRetries = 0;
    setTimeout(() => retryInjection(500), 800);
  });
  
  // MutationObserver to detect cart drawer opening
  // But don't interfere if UI already exists
  let observerTimeout;
  const observer = new MutationObserver((mutations) => {
    // Debounce observer calls
    clearTimeout(observerTimeout);
    observerTimeout = setTimeout(() => {
      let shouldInject = false;
      
      // Also hide protection product on any DOM mutation (cart updates)
      hideProtectionProduct();
      
      // Check if UI already exists and is properly rendered
      const existingUI = document.querySelector('.checkout-plus-embed');
      if (existingUI && existingUI.isConnected) {
        const hasButton = existingUI.querySelector('.checkout-plus-btn-primary');
        if (hasButton) {
          return; // UI exists and is complete
        } else {
          console.log('[checkout_plus] UI exists but incomplete, will retry');
          shouldInject = true;
        }
      }
      
      mutations.forEach((mutation) => {
        // Check if cart drawer was opened
        mutation.addedNodes.forEach((node) => {
          if (node.nodeType === 1) { // Element node
            // Check if this is a cart drawer
            for (const selector of CART_DRAWER_SELECTORS) {
              if (node.matches && node.matches(selector)) {
                shouldInject = true;
              }
              if (node.querySelector && node.querySelector(selector)) {
                shouldInject = true;
              }
            }
            
            // Check if cart drawer became visible
            if (node.classList) {
              const hasCartClass = Array.from(node.classList).some(cls => 
                cls.toLowerCase().includes('cart') && 
                (cls.toLowerCase().includes('drawer') || cls.toLowerCase().includes('open'))
              );
              if (hasCartClass) {
                shouldInject = true;
              }
            }
          }
        });
        
        // Check for attribute changes (drawer opening/closing)
        if (mutation.type === 'attributes') {
          const target = mutation.target;
          if (target && target.classList) {
            const isCartDrawer = CART_DRAWER_SELECTORS.some(sel => {
              try {
                return target.matches(sel) || target.closest(sel);
              } catch (e) {
                return false;
              }
            });
            
            if (isCartDrawer && (mutation.attributeName === 'class' || mutation.attributeName === 'style')) {
              const isVisible = target.offsetParent !== null && 
                              target.style.display !== 'none' &&
                              !target.classList.contains('hidden');
              if (isVisible) {
                shouldInject = true;
              }
            }
          }
        }
      });
      
      if (shouldInject) {
        injectionRetries = 0;
        // Longer delay for dynamic cart drawer opening (give other apps time to render)
        setTimeout(() => {
          retryInjection(400);
        }, 600);
      }
    }, 150);
  });
  
  // Start observing
  observer.observe(document.body, {
    childList: true,
    subtree: true,
    attributes: true,
    attributeFilter: ['class', 'style']
  });
  
  // Initial injection attempt
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
      setTimeout(() => {
        injectionRetries = 0;
        retryInjection(500);
      }, 500);
    });
  } else {
    setTimeout(() => {
      injectionRetries = 0;
      retryInjection(500);
    }, 500);
  }
  
  // Also try injecting on navigation (for SPA themes)
  let lastUrl = window.location.href;
  setInterval(() => {
    if (window.location.href !== lastUrl) {
      lastUrl = window.location.href;
      setTimeout(() => {
        injectedInstances.clear();
        injectionRetries = 0;
        retryInjection(500);
      }, 500);
    }
  }, 1000);
  
  // Listen for cart AJAX updates (common in modern themes)
  // Only intercept WRITE operations (add/change/update) not READ (cart.js)
  let isUpdatingViaFetch = false;
  let lastCartUpdate = 0;
  
  window.fetch = function(...args) {
    const url = args[0];
    const options = args[1] || {};
    const method = (options.method || 'GET').toUpperCase();
    
    // Don't intercept checkout, payment, or other critical operations
    if (typeof url === 'string') {
      // Skip checkout-related URLs
      if (url.includes('/checkout') || 
          url.includes('/payments') || 
          url.includes('/orders') ||
          url.includes('/thank_you')) {
        return originalFetch.apply(this, args);
      }
      
      // Only handle cart WRITE operations (POST = add/change/update)
      // Don't intercept cart.js GET requests to avoid infinite loop
      if ((url.includes('/cart/add') || url.includes('/cart/change') || url.includes('/cart/update')) && method === 'POST') {
        return originalFetch.apply(this, args).then(response => {
          // Debounce updates - only update once per 500ms
          const now = Date.now();
          if (now - lastCartUpdate < 500) {
            // Still check for empty cart even if debounced
            setTimeout(() => autoRemoveProtectionIfCartEmpty(), 600);
            return response;
          }
          lastCartUpdate = now;
          
          // Check if cart became empty and remove protection
          setTimeout(() => autoRemoveProtectionIfCartEmpty(), 600);
          
          // Trigger price update after cart change
          setTimeout(() => {
            document.querySelectorAll('.checkout-plus-embed').forEach(container => {
              if (container.isConnected) {
                // Dispatch event to trigger updatePrices
                document.dispatchEvent(new CustomEvent('cart:updated'));
              }
            });
          }, 300);
          
          return response;
        });
      }
    }
    return originalFetch.apply(this, args);
  };
  
})();
</script>

{% schema %}
{
  "name": "Checkout+ (Auto-inject)",
  "target": "body",
  "settings": []
}
{% endschema %}
